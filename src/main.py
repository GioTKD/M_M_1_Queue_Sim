"""

@author: Giovanni Arlotta

"""

"""
System state: number of costumers in the queue, server state

Entities: costumer generator, costumers, queue

Events: costumer arrival, service starting (dependent event), costumer, departure, simultion end

Activities: inter-arrival and service times

Delays: costumer waiting times

"""
import numpy as np

np.random.seed(0)

class Simulation:
    def __init__(self):
        self.numb_system = 0
        
        #SIMULATION VARIABLES

        self.clock = 0.0
        self.t_arrival = self.generate_interarrival()
        self.t_depart  = float('inf') #for now set to infinity
        
        #STATISTICAL COUNTERS
        
        self.num_arrivals = 0
        self.num_departs = 0
        self.total_wait = 0.0

    def advance_time(self):
        t_event = min(self.t_arrival,self.t_depart) # time the next event happens
        self.total_wait += self.numb_system*(t_event-self.clock) # update total wait by consider total number customers in a system * the time that passed (which is t_event - clock)
        #t_event-clock give me the step time until the duration from the last time step until the next event that's currently being processed
        self.clock = t_event # update the clock to the current event
        
        if self.t_arrival <=self.t_depart: # if arrival event happens first (arrival time less than departure time)
            self.handle_arrival_event()
        else:
            self.handle_depart_event()

    def handle_arrival_event(self):
        self.numb_system = self.numb_system +1 # increment number in the system
        self.num_arrivals = self.num_arrivals +1 # increment number of arrivals
        if self.numb_system <= 1: # if the customer who arrival is the only in the system
            self.t_depart = self.clock + self.generate_service() # in this case we set his departure time at the clock time + generate the service period for this customer
             # so if he is the only customer we schedule their departure
        else:
            self.t_arrival = self.clock + self.generate_interarrival() # otherwhise we need to see if there's more arrivals to process, by assign to next arrival clock + whatever value gets generated by interarrival period
    
    def handle_depart_event(self):
        self.numb_system = self.numb_system -1
        self.num_departs = self.num_departs +1
        if self.numb_system > 0:
            self.t_depart = self.clock + self.generate_service()
        else:
            self.t_depart = float('inf') # if there aren't any others customers in the system

    def generate_interarrival(self):
        return np.random.exponential(1./3) # Generate random exponential for inter_arrival
    
    def generate_service(self):
        return np.random.exponential(1./4)  # Generate random exponential for generating random service

s = Simulation()

for i in range(100):
    s.advance_time()