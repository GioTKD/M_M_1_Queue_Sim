"""

@author: Giovanni Arlotta

"""

"""
System state: number of costumers in the queue, server state

Entities: costumer generator, costumers, queue

Events: costumer arrival, service starting (dependent event), costumer, departure, simultion end

Activities: inter-arrival and service times

Delays: costumer waiting times

"""
import numpy as np
import matplotlib.pyplot as plt

np.random.seed(0)
wait_t = []
queue_c = []
utilization = []
val_utilization = 0
class Simulation:
    def __init__(self):
        self.queue_len = 0
        
        #SIMULATION VARIABLES

        self.clock = 0.0
        self.time_arrival = self.generate_interarrival()
        self.time_depart  = float('inf') #for now set to infinity
        
        #STATISTICAL COUNTERS
        
        self.num_arrivals = 0
        self.num_departs = 0
        self.total_wait = 0.0

    def inc_time(self):
        time_event = min(self.time_arrival,self.time_depart) # time the next event happens
        self.total_wait += self.queue_len*(time_event-self.clock) # update total wait by consider total number customers in a system * the time that passed (which is t_event - clock)
        #t_event-clock give me the step time until the duration from the last time step until the next event that's currently being processed
        self.clock = time_event # update the clock to the current event
        utilization.append(time_event)

        if self.time_arrival <=self.time_depart: # if arrival event happens first (arrival time less than departure time)
            self.handle_arrival_event()
        else:
            self.handle_depart_event()
        wait_t.append(time_event)
        
    def handle_arrival_event(self):
        self.queue_len = self.queue_len +1 # increment number in the system
        self.num_arrivals = self.num_arrivals +1 # increment number of arrivals
        if self.queue_len <= 1: # if the customer who arrival is the only in the system
            self.time_depart = self.clock + self.generate_service() # in this case we set his departure time at the clock time + generate the service period for this customer
             # so if he is the only customer we schedule their departure
        else:
            self.time_arrival = self.clock + self.generate_interarrival() # otherwhise we need to see if there's more arrivals to process, by assign to next arrival clock + whatever value gets generated by interarrival period
    
    def handle_depart_event(self):
        self.queue_len = self.queue_len -1
        self.num_departs = self.num_departs +1
        if self.queue_len > 0:
            self.time_depart = self.clock + self.generate_service()
        else:
            self.time_depart = float('inf') # if there aren't any others customers in the system

    def generate_interarrival(self):
        return np.random.exponential(1./3) # Generate random exponential for generate random time inter_arrival
    
    def generate_service(self):
        return np.random.exponential(1./4)  # Generate random exponential for generating random time for service

s = Simulation()

for i in range(10):
    queue_c.append(s.queue_len)
    s.inc_time()
print(queue_c)
val_utilization = utilization[9]-utilization[0]
print(val_utilization)
print(wait_t)
#plt.hist(wait_t)
#plt.xlabel('Waiting Time')
#plt.ylabel('Customers')
#plt.show()